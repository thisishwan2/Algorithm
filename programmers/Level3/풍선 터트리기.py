import math

# 이 문제에서 작은 풍선을 터뜨릴수 있다는 조건이 없다면, 항상 마지막에 남는 결과는 min(a)이다.
# 그러나, min(a)가 아닌 임의의 풍선 A를 풍선 터뜨리기의 결과로 남기려면 어떻게 해야할까?
# 그건, 마지막에 min(a)와 A만을 남기고, min(a)를 터뜨릴때, 작은 풍선을 터뜨리는 기회를 쓰는 것이다.
# 그러면 결과적으로 배열에 [min(a), A] 만 남기기 위해서는 어떻게 할 수 있을까?
# 즉, 위와 같이 남기기 위해서는 min(a)를 기준으로 쪼개면 알기 쉽다.
# 예를 들어 [20,50,40,30,-100] 이라는 배열이 있을때, -100을 기준으로 배열을 쪼개면
# [20,50,40,30] 이 된다. 그럼 이때, 하나씩 확인해보자.
# 20을 A라고 가정할때, 20 이후 숫자들은 어차피 -100이 다 터뜨릴 수 있으므로 항상 남는다.
# 50을 A라고 했을때, 20,50 은 20,50 에서 더 큰 연산만 가능하니까 50이 터지므로 50은 불가능하다.
# 40을 A라고 했을때, 20,50에서 20남기고, 20,40이라고 할때, 40이 더 크므로 40이 터지기 때문에 불가능하다.
# 30을 A라고 했을대, 위와 동일하게 20,30이 된다.
# 즉, 특정 A와 min(a) 사이의 수는 min(a)로 인해 터질거니까, 우리는 특정 A이전 수들만 비교해서 더 작은 수가 없으면 살아남을 수 있다.

# 이처럼  min(a)의 좌우로 배열을 쪼갠뒤, 양끝에서부터 최솟값을 확인하며, 더 작은 최소값을 만난 경우에만 카운트를 해주면 된다.
# 참고로 min(a)는 항상 남으니 +1을 꼭해준다.
def solution(a):
    minimum = min(a)
    minimum_index = a.index(minimum)

    cnt = 0
    temp = math.inf

    for i in range(0, minimum_index):
        if temp >= a[i]:
            temp = a[i]
            cnt += 1

    temp = math.inf

    for j in range(len(a)-1, minimum_index, -1):
        if temp >= a[j]:
            temp = a[j]
            cnt += 1

    answer = cnt + 1
    return answer